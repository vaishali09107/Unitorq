{"ast":null,"code":"/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.6\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n(function () {\n  'use strict';\n  /**\n   * Pathformer\n   * Beta version\n   *\n   * Take any SVG version 1.1 and transform\n   * child elements to 'path' elements\n   *\n   * This code is purely forked from\n   * https://github.com/Waest/SVGPathConverter\n   */\n\n  /**\n   * Class constructor\n   *\n   * @param {DOM|String} element Dom element of the SVG or id of it\n   */\n\n  function Pathformer(element) {\n    // Test params\n    if (typeof element === 'undefined') {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n    } // Set the element\n\n\n    if (element.constructor === String) {\n      element = document.getElementById(element);\n\n      if (!element) {\n        throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n      }\n    }\n\n    if (element instanceof window.SVGElement || element instanceof window.SVGGElement || /^svg$/i.test(element.nodeName)) {\n      this.el = element;\n    } else {\n      throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n    } // Start\n\n\n    this.scan(element);\n  }\n  /**\n   * List of tags which can be transformed\n   * to path elements\n   *\n   * @type {Array}\n   */\n\n\n  Pathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n  /**\n   * List of attribute names which contain\n   * data. This array list them to check if\n   * they contain bad values, like percentage.\n   *\n   * @type {Array}\n   */\n\n  Pathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n  /**\n   * Finds the elements compatible for transform\n   * and apply the liked method\n   *\n   * @param  {object} options Object from the constructor\n   */\n\n  Pathformer.prototype.scan = function (svg) {\n    var fn,\n        element,\n        pathData,\n        pathDom,\n        elements = svg.querySelectorAll(this.TYPES.join(','));\n\n    for (var i = 0; i < elements.length; i++) {\n      element = elements[i];\n      fn = this[element.tagName.toLowerCase() + 'ToPath'];\n      pathData = fn(this.parseAttr(element.attributes));\n      pathDom = this.pathMaker(element, pathData);\n      element.parentNode.replaceChild(pathDom, element);\n    }\n  };\n  /**\n   * Read `line` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element Line element to transform\n   * @return {object}             Data for a `path` element\n   */\n\n\n  Pathformer.prototype.lineToPath = function (element) {\n    var newElement = {},\n        x1 = element.x1 || 0,\n        y1 = element.y1 || 0,\n        x2 = element.x2 || 0,\n        y2 = element.y2 || 0;\n    newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n    return newElement;\n  };\n  /**\n   * Read `rect` element to extract and transform\n   * data, to make it ready for a `path` object.\n   * The radius-border is not taken in charge yet.\n   * (your help is more than welcomed)\n   *\n   * @param  {DOMelement} element Rect element to transform\n   * @return {object}             Data for a `path` element\n   */\n\n\n  Pathformer.prototype.rectToPath = function (element) {\n    var newElement = {},\n        x = parseFloat(element.x) || 0,\n        y = parseFloat(element.y) || 0,\n        width = parseFloat(element.width) || 0,\n        height = parseFloat(element.height) || 0;\n\n    if (element.rx || element.ry) {\n      var rx = parseInt(element.rx, 10) || -1,\n          ry = parseInt(element.ry, 10) || -1;\n      rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width / 2);\n      ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height / 2);\n      newElement.d = 'M ' + (x + rx) + ',' + y + ' ' + 'L ' + (x + width - rx) + ',' + y + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' + 'L ' + (x + width) + ',' + (y + height - ry) + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' + 'L ' + (x + rx) + ',' + (y + height) + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' + 'L ' + x + ',' + (y + ry) + ' ' + 'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n    } else {\n      newElement.d = 'M' + x + ' ' + y + ' ' + 'L' + (x + width) + ' ' + y + ' ' + 'L' + (x + width) + ' ' + (y + height) + ' ' + 'L' + x + ' ' + (y + height) + ' Z';\n    }\n\n    return newElement;\n  };\n  /**\n   * Read `polyline` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element Polyline element to transform\n   * @return {object}             Data for a `path` element\n   */\n\n\n  Pathformer.prototype.polylineToPath = function (element) {\n    var newElement = {},\n        points = element.points.trim().split(' '),\n        i,\n        path; // Reformatting if points are defined without commas\n\n    if (element.points.indexOf(',') === -1) {\n      var formattedPoints = [];\n\n      for (i = 0; i < points.length; i += 2) {\n        formattedPoints.push(points[i] + ',' + points[i + 1]);\n      }\n\n      points = formattedPoints;\n    } // Generate the path.d value\n\n\n    path = 'M' + points[0];\n\n    for (i = 1; i < points.length; i++) {\n      if (points[i].indexOf(',') !== -1) {\n        path += 'L' + points[i];\n      }\n    }\n\n    newElement.d = path;\n    return newElement;\n  };\n  /**\n   * Read `polygon` element to extract and transform\n   * data, to make it ready for a `path` object.\n   * This method rely on polylineToPath, because the\n   * logic is similar. The path created is just closed,\n   * so it needs an 'Z' at the end.\n   *\n   * @param  {DOMelement} element Polygon element to transform\n   * @return {object}             Data for a `path` element\n   */\n\n\n  Pathformer.prototype.polygonToPath = function (element) {\n    var newElement = Pathformer.prototype.polylineToPath(element);\n    newElement.d += 'Z';\n    return newElement;\n  };\n  /**\n   * Read `ellipse` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element ellipse element to transform\n   * @return {object}             Data for a `path` element\n   */\n\n\n  Pathformer.prototype.ellipseToPath = function (element) {\n    var newElement = {},\n        rx = parseFloat(element.rx) || 0,\n        ry = parseFloat(element.ry) || 0,\n        cx = parseFloat(element.cx) || 0,\n        cy = parseFloat(element.cy) || 0,\n        startX = cx - rx,\n        startY = cy,\n        endX = parseFloat(cx) + parseFloat(rx),\n        endY = cy;\n    newElement.d = 'M' + startX + ',' + startY + 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY + 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n    return newElement;\n  };\n  /**\n   * Read `circle` element to extract and transform\n   * data, to make it ready for a `path` object.\n   *\n   * @param  {DOMelement} element Circle element to transform\n   * @return {object}             Data for a `path` element\n   */\n\n\n  Pathformer.prototype.circleToPath = function (element) {\n    var newElement = {},\n        r = parseFloat(element.r) || 0,\n        cx = parseFloat(element.cx) || 0,\n        cy = parseFloat(element.cy) || 0,\n        startX = cx - r,\n        startY = cy,\n        endX = parseFloat(cx) + parseFloat(r),\n        endY = cy;\n    newElement.d = 'M' + startX + ',' + startY + 'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY + 'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n    return newElement;\n  };\n  /**\n   * Create `path` elements form original element\n   * and prepared objects\n   *\n   * @param  {DOMelement} element  Original element to transform\n   * @param  {object} pathData     Path data (from `toPath` methods)\n   * @return {DOMelement}          Path element\n   */\n\n\n  Pathformer.prototype.pathMaker = function (element, pathData) {\n    var i,\n        attr,\n        pathTag = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n\n    for (i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n\n      if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n        pathTag.setAttribute(attr.name, attr.value);\n      }\n    }\n\n    for (i in pathData) {\n      pathTag.setAttribute(i, pathData[i]);\n    }\n\n    return pathTag;\n  };\n  /**\n   * Parse attributes of a DOM element to\n   * get an object of attribute => value\n   *\n   * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n   * @return {object}                  Object of attributes\n   */\n\n\n  Pathformer.prototype.parseAttr = function (element) {\n    var attr,\n        output = {};\n\n    for (var i = 0; i < element.length; i++) {\n      attr = element[i]; // Check if no data attribute contains '%', or the transformation is impossible\n\n      if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n        throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n      }\n\n      output[attr.name] = attr.value;\n    }\n\n    return output;\n  };\n\n  'use strict';\n\n  var setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n  /**\n   * Vivus\n   * Beta version\n   *\n   * Take any SVG and make the animation\n   * to give give the impression of live drawing\n   *\n   * This in more than just inspired from codrops\n   * At that point, it's a pure fork.\n   */\n\n  /**\n   * Class constructor\n   * option structure\n   *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n   *   duration: <int> (in frames)\n   *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n   *   delay: <int> (delay between the drawing of first and last path)\n   *   dashGap <integer> whitespace extra margin between dashes\n   *   pathTimingFunction <function> timing animation function for each path element of the SVG\n   *   animTimingFunction <function> timing animation function for the complete SVG\n   *   forceRender <boolean> force the browser to re-render all updated path items\n   *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n   *\n   * The attribute 'type' is by default on 'delayed'.\n   *  - 'delayed'\n   *    all paths are draw at the same time but with a\n   *    little delay between them before start\n   *  - 'sync'\n   *    all path are start and finish at the same time\n   *  - 'oneByOne'\n   *    only one path is draw at the time\n   *    the end of the first one will trigger the draw\n   *    of the next one\n   *\n   * All these values can be overwritten individually\n   * for each path item in the SVG\n   * The value of frames will always take the advantage of\n   * the duration value.\n   * If you fail somewhere, an error will be thrown.\n   * Good luck.\n   *\n   * @constructor\n   * @this {Vivus}\n   * @param {DOM|String}   element  Dom element of the SVG or id of it\n   * @param {Object}       options  Options about the animation\n   * @param {Function}     callback Callback for the end of the animation\n   */\n\n  function Vivus(element, options, callback) {\n    setupEnv(); // Setup\n\n    this.isReady = false;\n    this.setElement(element, options);\n    this.setOptions(options);\n    this.setCallback(callback);\n\n    if (this.isReady) {\n      this.init();\n    }\n  }\n  /**\n   * Timing functions\n   **************************************\n   *\n   * Default functions to help developers.\n   * It always take a number as parameter (between 0 to 1) then\n   * return a number (between 0 and 1)\n   */\n\n\n  Vivus.LINEAR = function (x) {\n    return x;\n  };\n\n  Vivus.EASE = function (x) {\n    return -Math.cos(x * Math.PI) / 2 + 0.5;\n  };\n\n  Vivus.EASE_OUT = function (x) {\n    return 1 - Math.pow(1 - x, 3);\n  };\n\n  Vivus.EASE_IN = function (x) {\n    return Math.pow(x, 3);\n  };\n\n  Vivus.EASE_OUT_BOUNCE = function (x) {\n    var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n        rate = Math.pow(base, 1.5),\n        rateR = Math.pow(1 - x, 2),\n        progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI))) + 1;\n    return 1 - rateR + progress * rateR;\n  };\n  /**\n   * Setters\n   **************************************\n   */\n\n  /**\n   * Check and set the element in the instance\n   * The method will not return anything, but will throw an\n   * error if the parameter is invalid\n   *\n   * @param {DOM|String}   element  SVG Dom element or id of it\n   */\n\n\n  Vivus.prototype.setElement = function (element, options) {\n    var onLoad, self; // Basic check\n\n    if (typeof element === 'undefined') {\n      throw new Error('Vivus [constructor]: \"element\" parameter is required');\n    } // Set the element\n\n\n    if (element.constructor === String) {\n      element = document.getElementById(element);\n\n      if (!element) {\n        throw new Error('Vivus [constructor]: \"element\" parameter is not related to an existing ID');\n      }\n    }\n\n    this.parentEl = element; // Load the SVG with XMLHttpRequest and extract the SVG\n\n    if (options && options.file) {\n      self = this;\n\n      onLoad = function () {\n        var domSandbox = document.createElement('div');\n        domSandbox.innerHTML = this.responseText;\n        var svgTag = domSandbox.querySelector('svg');\n\n        if (!svgTag) {\n          throw new Error('Vivus [load]: Cannot find the SVG in the loaded file : ' + options.file);\n        }\n\n        self.el = svgTag;\n        self.el.setAttribute('width', '100%');\n        self.el.setAttribute('height', '100%');\n        self.parentEl.appendChild(self.el);\n        self.isReady = true;\n        self.init();\n        self = null;\n      };\n\n      var oReq = new window.XMLHttpRequest();\n      oReq.addEventListener('load', onLoad);\n      oReq.open('GET', options.file);\n      oReq.send();\n      return;\n    }\n\n    switch (element.constructor) {\n      case window.SVGSVGElement:\n      case window.SVGElement:\n      case window.SVGGElement:\n        this.el = element;\n        this.isReady = true;\n        break;\n\n      case window.HTMLObjectElement:\n        self = this;\n\n        onLoad = function (e) {\n          if (self.isReady) {\n            return;\n          }\n\n          self.el = element.contentDocument && element.contentDocument.querySelector('svg');\n\n          if (!self.el && e) {\n            throw new Error('Vivus [constructor]: object loaded does not contain any SVG');\n          } else if (self.el) {\n            if (element.getAttribute('built-by-vivus')) {\n              self.parentEl.insertBefore(self.el, element);\n              self.parentEl.removeChild(element);\n              self.el.setAttribute('width', '100%');\n              self.el.setAttribute('height', '100%');\n            }\n\n            self.isReady = true;\n            self.init();\n            self = null;\n          }\n        };\n\n        if (!onLoad()) {\n          element.addEventListener('load', onLoad);\n        }\n\n        break;\n\n      default:\n        throw new Error('Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)');\n    }\n  };\n  /**\n   * Set up user option to the instance\n   * The method will not return anything, but will throw an\n   * error if the parameter is invalid\n   *\n   * @param  {object} options Object from the constructor\n   */\n\n\n  Vivus.prototype.setOptions = function (options) {\n    var allowedTypes = ['delayed', 'sync', 'async', 'nsync', 'oneByOne', 'scenario', 'scenario-sync'];\n    var allowedStarts = ['inViewport', 'manual', 'autostart']; // Basic check\n\n    if (options !== undefined && options.constructor !== Object) {\n      throw new Error('Vivus [constructor]: \"options\" parameter must be an object');\n    } else {\n      options = options || {};\n    } // Set the animation type\n\n\n    if (options.type && allowedTypes.indexOf(options.type) === -1) {\n      throw new Error('Vivus [constructor]: ' + options.type + ' is not an existing animation `type`');\n    } else {\n      this.type = options.type || allowedTypes[0];\n    } // Set the start type\n\n\n    if (options.start && allowedStarts.indexOf(options.start) === -1) {\n      throw new Error('Vivus [constructor]: ' + options.start + ' is not an existing `start` option');\n    } else {\n      this.start = options.start || allowedStarts[0];\n    }\n\n    this.isIE = window.navigator.userAgent.indexOf('MSIE') !== -1 || window.navigator.userAgent.indexOf('Trident/') !== -1 || window.navigator.userAgent.indexOf('Edge/') !== -1;\n    this.duration = parsePositiveInt(options.duration, 120);\n    this.delay = parsePositiveInt(options.delay, null);\n    this.dashGap = parsePositiveInt(options.dashGap, 1);\n    this.forceRender = options.hasOwnProperty('forceRender') ? !!options.forceRender : this.isIE;\n    this.reverseStack = !!options.reverseStack;\n    this.selfDestroy = !!options.selfDestroy;\n    this.onReady = options.onReady;\n    this.map = [];\n    this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n    this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible') ? !!options.ignoreInvisible : false;\n    this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n    this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n    if (this.delay >= this.duration) {\n      throw new Error('Vivus [constructor]: delay must be shorter than duration');\n    }\n  };\n  /**\n   * Set up callback to the instance\n   * The method will not return enything, but will throw an\n   * error if the parameter is invalid\n   *\n   * @param  {Function} callback Callback for the animation end\n   */\n\n\n  Vivus.prototype.setCallback = function (callback) {\n    // Basic check\n    if (!!callback && callback.constructor !== Function) {\n      throw new Error('Vivus [constructor]: \"callback\" parameter must be a function');\n    }\n\n    this.callback = callback || function () {};\n  };\n  /**\n   * Core\n   **************************************\n   */\n\n  /**\n   * Map the svg, path by path.\n   * The method return nothing, it just fill the\n   * `map` array. Each item in this array represent\n   * a path element from the SVG, with informations for\n   * the animation.\n   *\n   * ```\n   * [\n   *   {\n   *     el: <DOMobj> the path element\n   *     length: <number> length of the path line\n   *     startAt: <number> time start of the path animation (in frames)\n   *     duration: <number> path animation duration (in frames)\n   *   },\n   *   ...\n   * ]\n   * ```\n   *\n   */\n\n\n  Vivus.prototype.mapping = function () {\n    var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint, scale, hasNonScale;\n    timePoint = totalLength = lengthMeter = 0;\n    paths = this.el.querySelectorAll('path');\n    hasNonScale = false;\n\n    for (i = 0; i < paths.length; i++) {\n      path = paths[i];\n\n      if (this.isInvisible(path)) {\n        continue;\n      }\n\n      pathObj = {\n        el: path,\n        length: 0,\n        startAt: 0,\n        duration: 0,\n        isResizeSensitive: false\n      }; // If vector effect is non-scaling-stroke, the total length won't match the rendered length\n      // so we need to calculate the scale and apply it\n\n      if (path.getAttribute('vector-effect') === 'non-scaling-stroke') {\n        var rect = path.getBoundingClientRect();\n        var box = path.getBBox();\n        scale = Math.max(rect.width / box.width, rect.height / box.height);\n        pathObj.isResizeSensitive = true;\n        hasNonScale = true;\n      } else {\n        scale = 1;\n      }\n\n      pathObj.length = Math.ceil(path.getTotalLength() * scale); // Test if the path length is correct\n\n      if (isNaN(pathObj.length)) {\n        if (window.console && console.warn) {\n          console.warn('Vivus [mapping]: cannot retrieve a path element length', path);\n        }\n\n        continue;\n      }\n\n      this.map.push(pathObj);\n      path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n      path.style.strokeDashoffset = pathObj.length + this.dashGap;\n      pathObj.length += this.dashGap;\n      totalLength += pathObj.length;\n      this.renderPath(i);\n    } // Show a warning for non-scaling elements\n\n\n    if (hasNonScale) {\n      console.warn('Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.');\n    }\n\n    totalLength = totalLength === 0 ? 1 : totalLength;\n    this.delay = this.delay === null ? this.duration / 3 : this.delay;\n    this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1); // Reverse stack if asked\n\n    if (this.reverseStack) {\n      this.map.reverse();\n    }\n\n    for (i = 0; i < this.map.length; i++) {\n      pathObj = this.map[i];\n\n      switch (this.type) {\n        case 'delayed':\n          pathObj.startAt = this.delayUnit * i;\n          pathObj.duration = this.duration - this.delay;\n          break;\n\n        case 'oneByOne':\n          pathObj.startAt = lengthMeter / totalLength * this.duration;\n          pathObj.duration = pathObj.length / totalLength * this.duration;\n          break;\n\n        case 'sync':\n        case 'async':\n        case 'nsync':\n          pathObj.startAt = 0;\n          pathObj.duration = this.duration;\n          break;\n\n        case 'scenario-sync':\n          path = pathObj.el;\n          pAttrs = this.parseAttr(path);\n          pathObj.startAt = timePoint + (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n          pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n          timePoint = pAttrs['data-async'] !== undefined ? pathObj.startAt : pathObj.startAt + pathObj.duration;\n          this.frameLength = Math.max(this.frameLength, pathObj.startAt + pathObj.duration);\n          break;\n\n        case 'scenario':\n          path = pathObj.el;\n          pAttrs = this.parseAttr(path);\n          pathObj.startAt = parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n          pathObj.duration = parsePositiveInt(pAttrs['data-duration'], this.duration);\n          this.frameLength = Math.max(this.frameLength, pathObj.startAt + pathObj.duration);\n          break;\n      }\n\n      lengthMeter += pathObj.length;\n      this.frameLength = this.frameLength || this.duration;\n    }\n  };\n  /**\n   * Public method to re-evaluate line length for non-scaling lines\n   * path elements.\n   */\n\n\n  Vivus.prototype.recalc = function () {\n    if (this.mustRecalcScale) {\n      return;\n    }\n\n    this.mustRecalcScale = requestAnimFrame(function () {\n      this.performLineRecalc();\n    }.bind(this));\n  };\n  /**\n   * Private method to re-evaluate line length on non-scaling\n   * path elements. Then call for a trace to update the SVG. \n   */\n\n\n  Vivus.prototype.performLineRecalc = function () {\n    var pathObj, path, rect, box, scale;\n\n    for (var i = 0; i < this.map.length; i++) {\n      pathObj = this.map[i];\n\n      if (pathObj.isResizeSensitive) {\n        path = pathObj.el;\n        rect = path.getBoundingClientRect();\n        box = path.getBBox();\n        scale = Math.max(rect.width / box.width, rect.height / box.height);\n        pathObj.length = Math.ceil(path.getTotalLength() * scale);\n        path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n      }\n    }\n\n    this.trace();\n    this.mustRecalcScale = null;\n  };\n  /**\n   * Interval method to draw the SVG from current\n   * position of the animation. It update the value of\n   * `currentFrame` and re-trace the SVG.\n   *\n   * It use this.handle to store the requestAnimationFrame\n   * and clear it one the animation is stopped. So this\n   * attribute can be used to know if the animation is\n   * playing.\n   *\n   * Once the animation at the end, this method will\n   * trigger the Vivus callback.\n   *\n   */\n\n\n  Vivus.prototype.draw = function () {\n    var self = this;\n    this.currentFrame += this.speed;\n\n    if (this.currentFrame <= 0) {\n      this.stop();\n      this.reset();\n    } else if (this.currentFrame >= this.frameLength) {\n      this.stop();\n      this.currentFrame = this.frameLength;\n      this.trace();\n\n      if (this.selfDestroy) {\n        this.destroy();\n      }\n    } else {\n      this.trace();\n      this.handle = requestAnimFrame(function () {\n        self.draw();\n      });\n      return;\n    }\n\n    this.callback(this);\n\n    if (this.instanceCallback) {\n      this.instanceCallback(this);\n      this.instanceCallback = null;\n    }\n  };\n  /**\n   * Draw the SVG at the current instant from the\n   * `currentFrame` value. Here is where most of the magic is.\n   * The trick is to use the `strokeDashoffset` style property.\n   *\n   * For optimisation reasons, a new property called `progress`\n   * is added in each item of `map`. This one contain the current\n   * progress of the path element. Only if the new value is different\n   * the new value will be applied to the DOM element. This\n   * method save a lot of resources to re-render the SVG. And could\n   * be improved if the animation couldn't be played forward.\n   *\n   */\n\n\n  Vivus.prototype.trace = function () {\n    var i, progress, path, currentFrame;\n    currentFrame = this.animTimingFunction(this.currentFrame / this.frameLength) * this.frameLength;\n\n    for (i = 0; i < this.map.length; i++) {\n      path = this.map[i];\n      progress = (currentFrame - path.startAt) / path.duration;\n      progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n\n      if (path.progress !== progress) {\n        path.progress = progress;\n        path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n        this.renderPath(i);\n      }\n    }\n  };\n  /**\n   * Method forcing the browser to re-render a path element\n   * from it's index in the map. Depending on the `forceRender`\n   * value.\n   * The trick is to replace the path element by it's clone.\n   * This practice is not recommended because it's asking more\n   * ressources, too much DOM manupulation..\n   * but it's the only way to let the magic happen on IE.\n   * By default, this fallback is only applied on IE.\n   *\n   * @param  {Number} index Path index\n   */\n\n\n  Vivus.prototype.renderPath = function (index) {\n    if (this.forceRender && this.map && this.map[index]) {\n      var pathObj = this.map[index],\n          newPath = pathObj.el.cloneNode(true);\n      pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n      pathObj.el = newPath;\n    }\n  };\n  /**\n   * When the SVG object is loaded and ready,\n   * this method will continue the initialisation.\n   *\n   * This this mainly due to the case of passing an\n   * object tag in the constructor. It will wait\n   * the end of the loading to initialise.\n   *\n   */\n\n\n  Vivus.prototype.init = function () {\n    // Set object variables\n    this.frameLength = 0;\n    this.currentFrame = 0;\n    this.map = []; // Start\n\n    new Pathformer(this.el);\n    this.mapping();\n    this.starter();\n\n    if (this.onReady) {\n      this.onReady(this);\n    }\n  };\n  /**\n   * Trigger to start of the animation.\n   * Depending on the `start` value, a different script\n   * will be applied.\n   *\n   * If the `start` value is not valid, an error will be thrown.\n   * Even if technically, this is impossible.\n   *\n   */\n\n\n  Vivus.prototype.starter = function () {\n    switch (this.start) {\n      case 'manual':\n        return;\n\n      case 'autostart':\n        this.play();\n        break;\n\n      case 'inViewport':\n        var self = this,\n            listener = function () {\n          if (self.isInViewport(self.parentEl, 1)) {\n            self.play();\n            window.removeEventListener('scroll', listener);\n          }\n        };\n\n        window.addEventListener('scroll', listener);\n        listener();\n        break;\n    }\n  };\n  /**\n   * Controls\n   **************************************\n   */\n\n  /**\n   * Get the current status of the animation between\n   * three different states: 'start', 'progress', 'end'.\n   * @return {string} Instance status\n   */\n\n\n  Vivus.prototype.getStatus = function () {\n    return this.currentFrame === 0 ? 'start' : this.currentFrame === this.frameLength ? 'end' : 'progress';\n  };\n  /**\n   * Reset the instance to the initial state : undraw\n   * Be careful, it just reset the animation, if you're\n   * playing the animation, this won't stop it. But just\n   * make it start from start.\n   *\n   */\n\n\n  Vivus.prototype.reset = function () {\n    return this.setFrameProgress(0);\n  };\n  /**\n   * Set the instance to the final state : drawn\n   * Be careful, it just set the animation, if you're\n   * playing the animation on rewind, this won't stop it.\n   * But just make it start from the end.\n   *\n   */\n\n\n  Vivus.prototype.finish = function () {\n    return this.setFrameProgress(1);\n  };\n  /**\n   * Set the level of progress of the drawing.\n   *\n   * @param {number} progress Level of progress to set\n   */\n\n\n  Vivus.prototype.setFrameProgress = function (progress) {\n    progress = Math.min(1, Math.max(0, progress));\n    this.currentFrame = Math.round(this.frameLength * progress);\n    this.trace();\n    return this;\n  };\n  /**\n   * Play the animation at the desired speed.\n   * Speed must be a valid number (no zero).\n   * By default, the speed value is 1.\n   * But a negative value is accepted to go forward.\n   *\n   * And works with float too.\n   * But don't forget we are in JavaScript, se be nice\n   * with him and give him a 1/2^x value.\n   *\n   * @param  {number} speed Animation speed [optional]\n   */\n\n\n  Vivus.prototype.play = function (speed, callback) {\n    this.instanceCallback = null;\n\n    if (speed && typeof speed === 'function') {\n      this.instanceCallback = speed; // first parameter is actually the callback function\n\n      speed = null;\n    } else if (speed && typeof speed !== 'number') {\n      throw new Error('Vivus [play]: invalid speed');\n    } // if the first parameter wasn't the callback, check if the seconds was\n\n\n    if (callback && typeof callback === 'function' && !this.instanceCallback) {\n      this.instanceCallback = callback;\n    }\n\n    this.speed = speed || 1;\n\n    if (!this.handle) {\n      this.draw();\n    }\n\n    return this;\n  };\n  /**\n   * Stop the current animation, if on progress.\n   * Should not trigger any error.\n   *\n   */\n\n\n  Vivus.prototype.stop = function () {\n    if (this.handle) {\n      cancelAnimFrame(this.handle);\n      this.handle = null;\n    }\n\n    return this;\n  };\n  /**\n   * Destroy the instance.\n   * Remove all bad styling attributes on all\n   * path tags\n   *\n   */\n\n\n  Vivus.prototype.destroy = function () {\n    this.stop();\n    var i, path;\n\n    for (i = 0; i < this.map.length; i++) {\n      path = this.map[i];\n      path.el.style.strokeDashoffset = null;\n      path.el.style.strokeDasharray = null;\n      this.renderPath(i);\n    }\n  };\n  /**\n   * Utils methods\n   * include methods from Codrops\n   **************************************\n   */\n\n  /**\n   * Method to best guess if a path should added into\n   * the animation or not.\n   *\n   * 1. Use the `data-vivus-ignore` attribute if set\n   * 2. Check if the instance must ignore invisible paths\n   * 3. Check if the path is visible\n   *\n   * For now the visibility checking is unstable.\n   * It will be used for a beta phase.\n   *\n   * Other improvments are planned. Like detecting\n   * is the path got a stroke or a valid opacity.\n   */\n\n\n  Vivus.prototype.isInvisible = function (el) {\n    var rect,\n        ignoreAttr = el.getAttribute('data-ignore');\n\n    if (ignoreAttr !== null) {\n      return ignoreAttr !== 'false';\n    }\n\n    if (this.ignoreInvisible) {\n      rect = el.getBoundingClientRect();\n      return !rect.width && !rect.height;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * Parse attributes of a DOM element to\n   * get an object of {attributeName => attributeValue}\n   *\n   * @param  {object} element DOM element to parse\n   * @return {object}         Object of attributes\n   */\n\n\n  Vivus.prototype.parseAttr = function (element) {\n    var attr,\n        output = {};\n\n    if (element && element.attributes) {\n      for (var i = 0; i < element.attributes.length; i++) {\n        attr = element.attributes[i];\n        output[attr.name] = attr.value;\n      }\n    }\n\n    return output;\n  };\n  /**\n   * Reply if an element is in the page viewport\n   *\n   * @param  {object} el Element to observe\n   * @param  {number} h  Percentage of height\n   * @return {boolean}\n   */\n\n\n  Vivus.prototype.isInViewport = function (el, h) {\n    var scrolled = this.scrollY(),\n        viewed = scrolled + this.getViewportH(),\n        elBCR = el.getBoundingClientRect(),\n        elHeight = elBCR.height,\n        elTop = scrolled + elBCR.top,\n        elBottom = elTop + elHeight; // if 0, the element is considered in the viewport as soon as it enters.\n    // if 1, the element is considered in the viewport only when it's fully inside\n    // value in percentage (1 >= h >= 0)\n\n    h = h || 0;\n    return elTop + elHeight * h <= viewed && elBottom >= scrolled;\n  };\n  /**\n   * Get the viewport height in pixels\n   *\n   * @return {integer} Viewport height\n   */\n\n\n  Vivus.prototype.getViewportH = function () {\n    var client = this.docElem.clientHeight,\n        inner = window.innerHeight;\n\n    if (client < inner) {\n      return inner;\n    } else {\n      return client;\n    }\n  };\n  /**\n   * Get the page Y offset\n   *\n   * @return {integer} Page Y offset\n   */\n\n\n  Vivus.prototype.scrollY = function () {\n    return window.pageYOffset || this.docElem.scrollTop;\n  };\n\n  setupEnv = function () {\n    if (Vivus.prototype.docElem) {\n      return;\n    }\n    /**\n     * Alias for document element\n     *\n     * @type {DOMelement}\n     */\n\n\n    Vivus.prototype.docElem = window.document.documentElement;\n    /**\n     * Alias for `requestAnimationFrame` or\n     * `setTimeout` function for deprecated browsers.\n     *\n     */\n\n    requestAnimFrame = function () {\n      return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (\n      /* function */\n      callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      };\n    }();\n    /**\n     * Alias for `cancelAnimationFrame` or\n     * `cancelTimeout` function for deprecated browsers.\n     *\n     */\n\n\n    cancelAnimFrame = function () {\n      return window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || function (id) {\n        return window.clearTimeout(id);\n      };\n    }();\n  };\n  /**\n   * Parse string to integer.\n   * If the number is not positive or null\n   * the method will return the default value\n   * or 0 if undefined\n   *\n   * @param {string} value String to parse\n   * @param {*} defaultValue Value to return if the result parsed is invalid\n   * @return {number}\n   *\n   */\n\n\n  parsePositiveInt = function (value, defaultValue) {\n    var output = parseInt(value, 10);\n    return output >= 0 ? output : defaultValue;\n  };\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function () {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n})();","map":{"version":3,"names":["Pathformer","element","Error","constructor","String","document","getElementById","window","SVGElement","SVGGElement","test","nodeName","el","scan","prototype","TYPES","ATTR_WATCH","svg","fn","pathData","pathDom","elements","querySelectorAll","join","i","length","tagName","toLowerCase","parseAttr","attributes","pathMaker","parentNode","replaceChild","lineToPath","newElement","x1","y1","x2","y2","d","rectToPath","x","parseFloat","y","width","height","rx","ry","parseInt","Math","min","max","polylineToPath","points","trim","split","path","indexOf","formattedPoints","push","polygonToPath","ellipseToPath","cx","cy","startX","startY","endX","endY","circleToPath","r","attr","pathTag","createElementNS","name","setAttribute","value","output","setupEnv","requestAnimFrame","cancelAnimFrame","parsePositiveInt","Vivus","options","callback","isReady","setElement","setOptions","setCallback","init","LINEAR","EASE","cos","PI","EASE_OUT","pow","EASE_IN","EASE_OUT_BOUNCE","base","rate","rateR","progress","abs","onLoad","self","parentEl","file","domSandbox","createElement","innerHTML","responseText","svgTag","querySelector","appendChild","oReq","XMLHttpRequest","addEventListener","open","send","SVGSVGElement","HTMLObjectElement","e","contentDocument","getAttribute","insertBefore","removeChild","allowedTypes","allowedStarts","undefined","Object","type","start","isIE","navigator","userAgent","duration","delay","dashGap","forceRender","hasOwnProperty","reverseStack","selfDestroy","onReady","map","frameLength","currentFrame","delayUnit","speed","handle","ignoreInvisible","animTimingFunction","pathTimingFunction","Function","mapping","paths","pAttrs","pathObj","totalLength","lengthMeter","timePoint","scale","hasNonScale","isInvisible","startAt","isResizeSensitive","rect","getBoundingClientRect","box","getBBox","ceil","getTotalLength","isNaN","console","warn","style","strokeDasharray","strokeDashoffset","renderPath","reverse","recalc","mustRecalcScale","performLineRecalc","bind","trace","draw","stop","reset","destroy","instanceCallback","floor","index","newPath","cloneNode","starter","play","listener","isInViewport","removeEventListener","getStatus","setFrameProgress","finish","round","ignoreAttr","h","scrolled","scrollY","viewed","getViewportH","elBCR","elHeight","elTop","top","elBottom","client","docElem","clientHeight","inner","innerHeight","pageYOffset","scrollTop","documentElement","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","msRequestAnimationFrame","setTimeout","cancelAnimationFrame","webkitCancelAnimationFrame","mozCancelAnimationFrame","oCancelAnimationFrame","msCancelAnimationFrame","id","clearTimeout","defaultValue","define","amd","exports","module"],"sources":["/Users/parthchavhan/Desktop/exomac-business-react-js-template-2023-11-27-05-26-00-utc/exomac/node_modules/vivus/dist/vivus.js"],"sourcesContent":["/**\n * vivus - JavaScript library to make drawing animation on SVG\n * @version v0.4.6\n * @link https://github.com/maxwellito/vivus\n * @license MIT\n */\n\n(function () {\n\n  'use strict';\n\n/**\n * Pathformer\n * Beta version\n *\n * Take any SVG version 1.1 and transform\n * child elements to 'path' elements\n *\n * This code is purely forked from\n * https://github.com/Waest/SVGPathConverter\n */\n\n/**\n * Class constructor\n *\n * @param {DOM|String} element Dom element of the SVG or id of it\n */\nfunction Pathformer(element) {\n  // Test params\n  if (typeof element === 'undefined') {\n    throw new Error('Pathformer [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error('Pathformer [constructor]: \"element\" parameter is not related to an existing ID');\n    }\n  }\n  if (element instanceof window.SVGElement || \n      element instanceof window.SVGGElement ||\n      /^svg$/i.test(element.nodeName)) {\n    this.el = element;\n  } else {\n    throw new Error('Pathformer [constructor]: \"element\" parameter must be a string or a SVGelement');\n  }\n\n  // Start\n  this.scan(element);\n}\n\n/**\n * List of tags which can be transformed\n * to path elements\n *\n * @type {Array}\n */\nPathformer.prototype.TYPES = ['line', 'ellipse', 'circle', 'polygon', 'polyline', 'rect'];\n\n/**\n * List of attribute names which contain\n * data. This array list them to check if\n * they contain bad values, like percentage.\n *\n * @type {Array}\n */\nPathformer.prototype.ATTR_WATCH = ['cx', 'cy', 'points', 'r', 'rx', 'ry', 'x', 'x1', 'x2', 'y', 'y1', 'y2'];\n\n/**\n * Finds the elements compatible for transform\n * and apply the liked method\n *\n * @param  {object} options Object from the constructor\n */\nPathformer.prototype.scan = function (svg) {\n  var fn, element, pathData, pathDom,\n      elements = svg.querySelectorAll(this.TYPES.join(','));\n\n  for (var i = 0; i < elements.length; i++) {\n    element = elements[i];\n    fn = this[element.tagName.toLowerCase() + 'ToPath'];\n    pathData = fn(this.parseAttr(element.attributes));\n    pathDom = this.pathMaker(element, pathData);\n    element.parentNode.replaceChild(pathDom, element);\n  }\n};\n\n\n/**\n * Read `line` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Line element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.lineToPath = function (element) {\n  var newElement = {},\n      x1 = element.x1 || 0,\n      y1 = element.y1 || 0,\n      x2 = element.x2 || 0,\n      y2 = element.y2 || 0;\n\n  newElement.d = 'M' + x1 + ',' + y1 + 'L' + x2 + ',' + y2;\n  return newElement;\n};\n\n/**\n * Read `rect` element to extract and transform\n * data, to make it ready for a `path` object.\n * The radius-border is not taken in charge yet.\n * (your help is more than welcomed)\n *\n * @param  {DOMelement} element Rect element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.rectToPath = function (element) {\n  var newElement = {},\n      x      = parseFloat(element.x)      || 0,\n      y      = parseFloat(element.y)      || 0,\n      width  = parseFloat(element.width)  || 0,\n      height = parseFloat(element.height) || 0;\n\n  if (element.rx || element.ry) {\n    var rx = parseInt(element.rx, 10) || -1,\n        ry = parseInt(element.ry, 10) || -1;\n    rx = Math.min(Math.max(rx < 0 ? ry : rx, 0), width/2);\n    ry = Math.min(Math.max(ry < 0 ? rx : ry, 0), height/2);\n\n    newElement.d = 'M ' + (x + rx) + ',' + y + ' ' +\n                   'L ' + (x + width - rx) + ',' + y + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width) + ',' + (y + ry) + ' ' +\n                   'L ' + (x + width) + ',' + (y + height - ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + width - rx) + ',' + (y + height) + ' ' +\n                   'L ' + (x + rx) + ',' + (y + height) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + x + ',' + (y + height - ry) + ' ' +\n                   'L ' + x + ',' + (y + ry) + ' ' +\n                   'A ' + rx + ',' + ry + ',0,0,1,' + (x + rx) + ',' + y;\n  }\n  else {\n    newElement.d = 'M' + x + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + y + ' ' +\n                   'L' + (x + width) + ' ' + (y + height) + ' ' +\n                   'L' + x + ' ' + (y + height) + ' Z';\n  }\n  return newElement;\n};\n\n/**\n * Read `polyline` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Polyline element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polylineToPath = function (element) {\n  var newElement = {},\n      points = element.points.trim().split(' '),\n      i, path;\n\n  // Reformatting if points are defined without commas\n  if (element.points.indexOf(',') === -1) {\n    var formattedPoints = [];\n    for (i = 0; i < points.length; i+=2) {\n      formattedPoints.push(points[i] + ',' + points[i+1]);\n    }\n    points = formattedPoints;\n  }\n\n  // Generate the path.d value\n  path = 'M' + points[0];\n  for(i = 1; i < points.length; i++) {\n    if (points[i].indexOf(',') !== -1) {\n      path += 'L' + points[i];\n    }\n  }\n  newElement.d = path;\n  return newElement;\n};\n\n/**\n * Read `polygon` element to extract and transform\n * data, to make it ready for a `path` object.\n * This method rely on polylineToPath, because the\n * logic is similar. The path created is just closed,\n * so it needs an 'Z' at the end.\n *\n * @param  {DOMelement} element Polygon element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.polygonToPath = function (element) {\n  var newElement = Pathformer.prototype.polylineToPath(element);\n\n  newElement.d += 'Z';\n  return newElement;\n};\n\n/**\n * Read `ellipse` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element ellipse element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.ellipseToPath = function (element) {\n  var newElement = {},\n      rx = parseFloat(element.rx) || 0,\n      ry = parseFloat(element.ry) || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - rx,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(rx),\n      endY = cy;\n\n  newElement.d = 'M' + startX + ',' + startY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + endX + ',' + endY +\n                 'A' + rx + ',' + ry + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Read `circle` element to extract and transform\n * data, to make it ready for a `path` object.\n *\n * @param  {DOMelement} element Circle element to transform\n * @return {object}             Data for a `path` element\n */\nPathformer.prototype.circleToPath = function (element) {\n  var newElement = {},\n      r  = parseFloat(element.r)  || 0,\n      cx = parseFloat(element.cx) || 0,\n      cy = parseFloat(element.cy) || 0,\n      startX = cx - r,\n      startY = cy,\n      endX = parseFloat(cx) + parseFloat(r),\n      endY = cy;\n      \n  newElement.d =  'M' + startX + ',' + startY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + endX + ',' + endY +\n                  'A' + r + ',' + r + ' 0,1,1 ' + startX + ',' + endY;\n  return newElement;\n};\n\n/**\n * Create `path` elements form original element\n * and prepared objects\n *\n * @param  {DOMelement} element  Original element to transform\n * @param  {object} pathData     Path data (from `toPath` methods)\n * @return {DOMelement}          Path element\n */\nPathformer.prototype.pathMaker = function (element, pathData) {\n  var i, attr, pathTag = document.createElementNS('http://www.w3.org/2000/svg','path');\n  for(i = 0; i < element.attributes.length; i++) {\n    attr = element.attributes[i];\n    if (this.ATTR_WATCH.indexOf(attr.name) === -1) {\n      pathTag.setAttribute(attr.name, attr.value);\n    }\n  }\n  for(i in pathData) {\n    pathTag.setAttribute(i, pathData[i]);\n  }\n  return pathTag;\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of attribute => value\n *\n * @param  {NamedNodeMap} attributes Attributes object from DOM element to parse\n * @return {object}                  Object of attributes\n */\nPathformer.prototype.parseAttr = function (element) {\n  var attr, output = {};\n  for (var i = 0; i < element.length; i++) {\n    attr = element[i];\n    // Check if no data attribute contains '%', or the transformation is impossible\n    if (this.ATTR_WATCH.indexOf(attr.name) !== -1 && attr.value.indexOf('%') !== -1) {\n      throw new Error('Pathformer [parseAttr]: a SVG shape got values in percentage. This cannot be transformed into \\'path\\' tags. Please use \\'viewBox\\'.');\n    }\n    output[attr.name] = attr.value;\n  }\n  return output;\n};\n\n  'use strict';\n\nvar setupEnv, requestAnimFrame, cancelAnimFrame, parsePositiveInt;\n\n/**\n * Vivus\n * Beta version\n *\n * Take any SVG and make the animation\n * to give give the impression of live drawing\n *\n * This in more than just inspired from codrops\n * At that point, it's a pure fork.\n */\n\n/**\n * Class constructor\n * option structure\n *   type: 'delayed'|'sync'|'oneByOne'|'script' (to know if the items must be drawn synchronously or not, default: delayed)\n *   duration: <int> (in frames)\n *   start: 'inViewport'|'manual'|'autostart' (start automatically the animation, default: inViewport)\n *   delay: <int> (delay between the drawing of first and last path)\n *   dashGap <integer> whitespace extra margin between dashes\n *   pathTimingFunction <function> timing animation function for each path element of the SVG\n *   animTimingFunction <function> timing animation function for the complete SVG\n *   forceRender <boolean> force the browser to re-render all updated path items\n *   selfDestroy <boolean> removes all extra styling on the SVG, and leaves it as original\n *\n * The attribute 'type' is by default on 'delayed'.\n *  - 'delayed'\n *    all paths are draw at the same time but with a\n *    little delay between them before start\n *  - 'sync'\n *    all path are start and finish at the same time\n *  - 'oneByOne'\n *    only one path is draw at the time\n *    the end of the first one will trigger the draw\n *    of the next one\n *\n * All these values can be overwritten individually\n * for each path item in the SVG\n * The value of frames will always take the advantage of\n * the duration value.\n * If you fail somewhere, an error will be thrown.\n * Good luck.\n *\n * @constructor\n * @this {Vivus}\n * @param {DOM|String}   element  Dom element of the SVG or id of it\n * @param {Object}       options  Options about the animation\n * @param {Function}     callback Callback for the end of the animation\n */\nfunction Vivus(element, options, callback) {\n  setupEnv();\n\n  // Setup\n  this.isReady = false;\n  this.setElement(element, options);\n  this.setOptions(options);\n  this.setCallback(callback);\n\n  if (this.isReady) {\n    this.init();\n  }\n}\n\n/**\n * Timing functions\n **************************************\n *\n * Default functions to help developers.\n * It always take a number as parameter (between 0 to 1) then\n * return a number (between 0 and 1)\n */\nVivus.LINEAR = function(x) {\n  return x;\n};\nVivus.EASE = function(x) {\n  return -Math.cos(x * Math.PI) / 2 + 0.5;\n};\nVivus.EASE_OUT = function(x) {\n  return 1 - Math.pow(1 - x, 3);\n};\nVivus.EASE_IN = function(x) {\n  return Math.pow(x, 3);\n};\nVivus.EASE_OUT_BOUNCE = function(x) {\n  var base = -Math.cos(x * (0.5 * Math.PI)) + 1,\n    rate = Math.pow(base, 1.5),\n    rateR = Math.pow(1 - x, 2),\n    progress = -Math.abs(Math.cos(rate * (2.5 * Math.PI))) + 1;\n  return 1 - rateR + progress * rateR;\n};\n\n/**\n * Setters\n **************************************\n */\n\n/**\n * Check and set the element in the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param {DOM|String}   element  SVG Dom element or id of it\n */\nVivus.prototype.setElement = function(element, options) {\n  var onLoad, self;\n\n  // Basic check\n  if (typeof element === 'undefined') {\n    throw new Error('Vivus [constructor]: \"element\" parameter is required');\n  }\n\n  // Set the element\n  if (element.constructor === String) {\n    element = document.getElementById(element);\n    if (!element) {\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not related to an existing ID'\n      );\n    }\n  }\n  this.parentEl = element;\n\n  // Load the SVG with XMLHttpRequest and extract the SVG\n  if (options && options.file) {\n    self = this;\n    onLoad = function() {\n      var domSandbox = document.createElement('div');\n      domSandbox.innerHTML = this.responseText;\n\n      var svgTag = domSandbox.querySelector('svg');\n      if (!svgTag) {\n        throw new Error(\n          'Vivus [load]: Cannot find the SVG in the loaded file : ' +\n            options.file\n        );\n      }\n\n      self.el = svgTag;\n      self.el.setAttribute('width', '100%');\n      self.el.setAttribute('height', '100%');\n      self.parentEl.appendChild(self.el);\n      self.isReady = true;\n      self.init();\n      self = null;\n    };\n\n    var oReq = new window.XMLHttpRequest();\n    oReq.addEventListener('load', onLoad);\n    oReq.open('GET', options.file);\n    oReq.send();\n    return;\n  }\n\n  switch (element.constructor) {\n    case window.SVGSVGElement:\n    case window.SVGElement:\n    case window.SVGGElement:\n      this.el = element;\n      this.isReady = true;\n      break;\n\n    case window.HTMLObjectElement:\n      self = this;\n      onLoad = function(e) {\n        if (self.isReady) {\n          return;\n        }\n        self.el =\n          element.contentDocument &&\n          element.contentDocument.querySelector('svg');\n        if (!self.el && e) {\n          throw new Error(\n            'Vivus [constructor]: object loaded does not contain any SVG'\n          );\n        } else if (self.el) {\n          if (element.getAttribute('built-by-vivus')) {\n            self.parentEl.insertBefore(self.el, element);\n            self.parentEl.removeChild(element);\n            self.el.setAttribute('width', '100%');\n            self.el.setAttribute('height', '100%');\n          }\n          self.isReady = true;\n          self.init();\n          self = null;\n        }\n      };\n\n      if (!onLoad()) {\n        element.addEventListener('load', onLoad);\n      }\n      break;\n\n    default:\n      throw new Error(\n        'Vivus [constructor]: \"element\" parameter is not valid (or miss the \"file\" attribute)'\n      );\n  }\n};\n\n/**\n * Set up user option to the instance\n * The method will not return anything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {object} options Object from the constructor\n */\nVivus.prototype.setOptions = function(options) {\n  var allowedTypes = [\n    'delayed',\n    'sync',\n    'async',\n    'nsync',\n    'oneByOne',\n    'scenario',\n    'scenario-sync'\n  ];\n  var allowedStarts = ['inViewport', 'manual', 'autostart'];\n\n  // Basic check\n  if (options !== undefined && options.constructor !== Object) {\n    throw new Error(\n      'Vivus [constructor]: \"options\" parameter must be an object'\n    );\n  } else {\n    options = options || {};\n  }\n\n  // Set the animation type\n  if (options.type && allowedTypes.indexOf(options.type) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.type +\n        ' is not an existing animation `type`'\n    );\n  } else {\n    this.type = options.type || allowedTypes[0];\n  }\n\n  // Set the start type\n  if (options.start && allowedStarts.indexOf(options.start) === -1) {\n    throw new Error(\n      'Vivus [constructor]: ' +\n        options.start +\n        ' is not an existing `start` option'\n    );\n  } else {\n    this.start = options.start || allowedStarts[0];\n  }\n\n  this.isIE =\n    window.navigator.userAgent.indexOf('MSIE') !== -1 ||\n    window.navigator.userAgent.indexOf('Trident/') !== -1 ||\n    window.navigator.userAgent.indexOf('Edge/') !== -1;\n  this.duration = parsePositiveInt(options.duration, 120);\n  this.delay = parsePositiveInt(options.delay, null);\n  this.dashGap = parsePositiveInt(options.dashGap, 1);\n  this.forceRender = options.hasOwnProperty('forceRender')\n    ? !!options.forceRender\n    : this.isIE;\n  this.reverseStack = !!options.reverseStack;\n  this.selfDestroy = !!options.selfDestroy;\n  this.onReady = options.onReady;\n  this.map = [];\n  this.frameLength = this.currentFrame = this.delayUnit = this.speed = this.handle = null;\n\n  this.ignoreInvisible = options.hasOwnProperty('ignoreInvisible')\n    ? !!options.ignoreInvisible\n    : false;\n\n  this.animTimingFunction = options.animTimingFunction || Vivus.LINEAR;\n  this.pathTimingFunction = options.pathTimingFunction || Vivus.LINEAR;\n\n  if (this.delay >= this.duration) {\n    throw new Error('Vivus [constructor]: delay must be shorter than duration');\n  }\n};\n\n/**\n * Set up callback to the instance\n * The method will not return enything, but will throw an\n * error if the parameter is invalid\n *\n * @param  {Function} callback Callback for the animation end\n */\nVivus.prototype.setCallback = function(callback) {\n  // Basic check\n  if (!!callback && callback.constructor !== Function) {\n    throw new Error(\n      'Vivus [constructor]: \"callback\" parameter must be a function'\n    );\n  }\n  this.callback = callback || function() {};\n};\n\n/**\n * Core\n **************************************\n */\n\n/**\n * Map the svg, path by path.\n * The method return nothing, it just fill the\n * `map` array. Each item in this array represent\n * a path element from the SVG, with informations for\n * the animation.\n *\n * ```\n * [\n *   {\n *     el: <DOMobj> the path element\n *     length: <number> length of the path line\n *     startAt: <number> time start of the path animation (in frames)\n *     duration: <number> path animation duration (in frames)\n *   },\n *   ...\n * ]\n * ```\n *\n */\nVivus.prototype.mapping = function() {\n  var i, paths, path, pAttrs, pathObj, totalLength, lengthMeter, timePoint, scale, hasNonScale;\n  timePoint = totalLength = lengthMeter = 0;\n  paths = this.el.querySelectorAll('path');\n  hasNonScale = false;\n\n  for (i = 0; i < paths.length; i++) {\n    path = paths[i];\n    if (this.isInvisible(path)) {\n      continue;\n    }\n\n    pathObj = {\n      el: path,\n      length: 0,\n      startAt: 0,\n      duration: 0,\n      isResizeSensitive: false\n    };\n\n    // If vector effect is non-scaling-stroke, the total length won't match the rendered length\n    // so we need to calculate the scale and apply it\n    if (path.getAttribute('vector-effect') === 'non-scaling-stroke') {\n      var rect = path.getBoundingClientRect();\n      var box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.isResizeSensitive = true;\n      hasNonScale = true;\n    } else {\n      scale = 1;\n    }\n    pathObj.length = Math.ceil(path.getTotalLength() * scale);\n\n    // Test if the path length is correct\n    if (isNaN(pathObj.length)) {\n      if (window.console && console.warn) {\n        console.warn(\n          'Vivus [mapping]: cannot retrieve a path element length',\n          path\n        );\n      }\n      continue;\n    }\n    this.map.push(pathObj);\n    path.style.strokeDasharray =\n      pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    path.style.strokeDashoffset = pathObj.length + this.dashGap;\n    pathObj.length += this.dashGap;\n    totalLength += pathObj.length;\n\n    this.renderPath(i);\n  }\n\n  // Show a warning for non-scaling elements\n  if (hasNonScale) {\n    console.warn('Vivus: this SVG contains non-scaling-strokes. You should call instance.recalc() when the SVG is resized or you will encounter unwanted behaviour. See https://github.com/maxwellito/vivus#non-scaling for more info.');\n  }\n\n  totalLength = totalLength === 0 ? 1 : totalLength;\n  this.delay = this.delay === null ? this.duration / 3 : this.delay;\n  this.delayUnit = this.delay / (paths.length > 1 ? paths.length - 1 : 1);\n\n  // Reverse stack if asked\n  if (this.reverseStack) {\n    this.map.reverse();\n  }\n\n  for (i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n\n    switch (this.type) {\n      case 'delayed':\n        pathObj.startAt = this.delayUnit * i;\n        pathObj.duration = this.duration - this.delay;\n        break;\n\n      case 'oneByOne':\n        pathObj.startAt = (lengthMeter / totalLength) * this.duration;\n        pathObj.duration = (pathObj.length / totalLength) * this.duration;\n        break;\n\n      case 'sync':\n      case 'async':\n      case 'nsync':\n        pathObj.startAt = 0;\n        pathObj.duration = this.duration;\n        break;\n\n      case 'scenario-sync':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          timePoint +\n          (parsePositiveInt(pAttrs['data-delay'], this.delayUnit) || 0);\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        timePoint =\n          pAttrs['data-async'] !== undefined\n            ? pathObj.startAt\n            : pathObj.startAt + pathObj.duration;\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n\n      case 'scenario':\n        path = pathObj.el;\n        pAttrs = this.parseAttr(path);\n        pathObj.startAt =\n          parsePositiveInt(pAttrs['data-start'], this.delayUnit) || 0;\n        pathObj.duration = parsePositiveInt(\n          pAttrs['data-duration'],\n          this.duration\n        );\n        this.frameLength = Math.max(\n          this.frameLength,\n          pathObj.startAt + pathObj.duration\n        );\n        break;\n    }\n    lengthMeter += pathObj.length;\n    this.frameLength = this.frameLength || this.duration;\n  }\n};\n\n/**\n * Public method to re-evaluate line length for non-scaling lines\n * path elements.\n */\nVivus.prototype.recalc = function () {\n  if (this.mustRecalcScale) {\n    return;\n  }\n  this.mustRecalcScale = requestAnimFrame(function () {\n    this.performLineRecalc();\n  }.bind(this));\n}\n\n/**\n * Private method to re-evaluate line length on non-scaling\n * path elements. Then call for a trace to update the SVG. \n */\nVivus.prototype.performLineRecalc = function () {\n  var pathObj, path, rect, box, scale;\n  for (var i = 0; i < this.map.length; i++) {\n    pathObj = this.map[i];\n    if (pathObj.isResizeSensitive) {\n      path = pathObj.el;\n      rect = path.getBoundingClientRect();\n      box = path.getBBox();\n      scale = Math.max(rect.width / box.width, rect.height / box.height);\n      pathObj.length = Math.ceil(path.getTotalLength() * scale);\n      path.style.strokeDasharray = pathObj.length + ' ' + (pathObj.length + this.dashGap * 2);\n    }\n  }\n  this.trace();\n  this.mustRecalcScale = null;\n}\n\n/**\n * Interval method to draw the SVG from current\n * position of the animation. It update the value of\n * `currentFrame` and re-trace the SVG.\n *\n * It use this.handle to store the requestAnimationFrame\n * and clear it one the animation is stopped. So this\n * attribute can be used to know if the animation is\n * playing.\n *\n * Once the animation at the end, this method will\n * trigger the Vivus callback.\n *\n */\nVivus.prototype.draw = function() {\n  var self = this;\n  this.currentFrame += this.speed;\n\n  if (this.currentFrame <= 0) {\n    this.stop();\n    this.reset();\n  } else if (this.currentFrame >= this.frameLength) {\n    this.stop();\n    this.currentFrame = this.frameLength;\n    this.trace();\n    if (this.selfDestroy) {\n      this.destroy();\n    }\n  } else {\n    this.trace();\n    this.handle = requestAnimFrame(function() {\n      self.draw();\n    });\n    return;\n  }\n\n  this.callback(this);\n  if (this.instanceCallback) {\n    this.instanceCallback(this);\n    this.instanceCallback = null;\n  }\n};\n\n/**\n * Draw the SVG at the current instant from the\n * `currentFrame` value. Here is where most of the magic is.\n * The trick is to use the `strokeDashoffset` style property.\n *\n * For optimisation reasons, a new property called `progress`\n * is added in each item of `map`. This one contain the current\n * progress of the path element. Only if the new value is different\n * the new value will be applied to the DOM element. This\n * method save a lot of resources to re-render the SVG. And could\n * be improved if the animation couldn't be played forward.\n *\n */\nVivus.prototype.trace = function() {\n  var i, progress, path, currentFrame;\n  currentFrame =\n    this.animTimingFunction(this.currentFrame / this.frameLength) *\n    this.frameLength;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    progress = (currentFrame - path.startAt) / path.duration;\n    progress = this.pathTimingFunction(Math.max(0, Math.min(1, progress)));\n    if (path.progress !== progress) {\n      path.progress = progress;\n      path.el.style.strokeDashoffset = Math.floor(path.length * (1 - progress));\n      this.renderPath(i);\n    }\n  }\n};\n\n/**\n * Method forcing the browser to re-render a path element\n * from it's index in the map. Depending on the `forceRender`\n * value.\n * The trick is to replace the path element by it's clone.\n * This practice is not recommended because it's asking more\n * ressources, too much DOM manupulation..\n * but it's the only way to let the magic happen on IE.\n * By default, this fallback is only applied on IE.\n *\n * @param  {Number} index Path index\n */\nVivus.prototype.renderPath = function(index) {\n  if (this.forceRender && this.map && this.map[index]) {\n    var pathObj = this.map[index],\n      newPath = pathObj.el.cloneNode(true);\n    pathObj.el.parentNode.replaceChild(newPath, pathObj.el);\n    pathObj.el = newPath;\n  }\n};\n\n/**\n * When the SVG object is loaded and ready,\n * this method will continue the initialisation.\n *\n * This this mainly due to the case of passing an\n * object tag in the constructor. It will wait\n * the end of the loading to initialise.\n *\n */\nVivus.prototype.init = function() {\n  // Set object variables\n  this.frameLength = 0;\n  this.currentFrame = 0;\n  this.map = [];\n\n  // Start\n  new Pathformer(this.el);\n  this.mapping();\n  this.starter();\n\n  if (this.onReady) {\n    this.onReady(this);\n  }\n};\n\n/**\n * Trigger to start of the animation.\n * Depending on the `start` value, a different script\n * will be applied.\n *\n * If the `start` value is not valid, an error will be thrown.\n * Even if technically, this is impossible.\n *\n */\nVivus.prototype.starter = function() {\n  switch (this.start) {\n    case 'manual':\n      return;\n\n    case 'autostart':\n      this.play();\n      break;\n\n    case 'inViewport':\n      var self = this,\n        listener = function() {\n          if (self.isInViewport(self.parentEl, 1)) {\n            self.play();\n            window.removeEventListener('scroll', listener);\n          }\n        };\n      window.addEventListener('scroll', listener);\n      listener();\n      break;\n  }\n};\n\n/**\n * Controls\n **************************************\n */\n\n/**\n * Get the current status of the animation between\n * three different states: 'start', 'progress', 'end'.\n * @return {string} Instance status\n */\nVivus.prototype.getStatus = function() {\n  return this.currentFrame === 0\n    ? 'start'\n    : this.currentFrame === this.frameLength\n    ? 'end'\n    : 'progress';\n};\n\n/**\n * Reset the instance to the initial state : undraw\n * Be careful, it just reset the animation, if you're\n * playing the animation, this won't stop it. But just\n * make it start from start.\n *\n */\nVivus.prototype.reset = function() {\n  return this.setFrameProgress(0);\n};\n\n/**\n * Set the instance to the final state : drawn\n * Be careful, it just set the animation, if you're\n * playing the animation on rewind, this won't stop it.\n * But just make it start from the end.\n *\n */\nVivus.prototype.finish = function() {\n  return this.setFrameProgress(1);\n};\n\n/**\n * Set the level of progress of the drawing.\n *\n * @param {number} progress Level of progress to set\n */\nVivus.prototype.setFrameProgress = function(progress) {\n  progress = Math.min(1, Math.max(0, progress));\n  this.currentFrame = Math.round(this.frameLength * progress);\n  this.trace();\n  return this;\n};\n\n/**\n * Play the animation at the desired speed.\n * Speed must be a valid number (no zero).\n * By default, the speed value is 1.\n * But a negative value is accepted to go forward.\n *\n * And works with float too.\n * But don't forget we are in JavaScript, se be nice\n * with him and give him a 1/2^x value.\n *\n * @param  {number} speed Animation speed [optional]\n */\nVivus.prototype.play = function(speed, callback) {\n  this.instanceCallback = null;\n\n  if (speed && typeof speed === 'function') {\n    this.instanceCallback = speed; // first parameter is actually the callback function\n    speed = null;\n  } else if (speed && typeof speed !== 'number') {\n    throw new Error('Vivus [play]: invalid speed');\n  }\n  // if the first parameter wasn't the callback, check if the seconds was\n  if (callback && typeof callback === 'function' && !this.instanceCallback) {\n    this.instanceCallback = callback;\n  }\n\n  this.speed = speed || 1;\n  if (!this.handle) {\n    this.draw();\n  }\n  return this;\n};\n\n/**\n * Stop the current animation, if on progress.\n * Should not trigger any error.\n *\n */\nVivus.prototype.stop = function() {\n  if (this.handle) {\n    cancelAnimFrame(this.handle);\n    this.handle = null;\n  }\n  return this;\n};\n\n/**\n * Destroy the instance.\n * Remove all bad styling attributes on all\n * path tags\n *\n */\nVivus.prototype.destroy = function() {\n  this.stop();\n  var i, path;\n  for (i = 0; i < this.map.length; i++) {\n    path = this.map[i];\n    path.el.style.strokeDashoffset = null;\n    path.el.style.strokeDasharray = null;\n    this.renderPath(i);\n  }\n};\n\n/**\n * Utils methods\n * include methods from Codrops\n **************************************\n */\n\n/**\n * Method to best guess if a path should added into\n * the animation or not.\n *\n * 1. Use the `data-vivus-ignore` attribute if set\n * 2. Check if the instance must ignore invisible paths\n * 3. Check if the path is visible\n *\n * For now the visibility checking is unstable.\n * It will be used for a beta phase.\n *\n * Other improvments are planned. Like detecting\n * is the path got a stroke or a valid opacity.\n */\nVivus.prototype.isInvisible = function(el) {\n  var rect,\n    ignoreAttr = el.getAttribute('data-ignore');\n\n  if (ignoreAttr !== null) {\n    return ignoreAttr !== 'false';\n  }\n\n  if (this.ignoreInvisible) {\n    rect = el.getBoundingClientRect();\n    return !rect.width && !rect.height;\n  } else {\n    return false;\n  }\n};\n\n/**\n * Parse attributes of a DOM element to\n * get an object of {attributeName => attributeValue}\n *\n * @param  {object} element DOM element to parse\n * @return {object}         Object of attributes\n */\nVivus.prototype.parseAttr = function(element) {\n  var attr,\n    output = {};\n  if (element && element.attributes) {\n    for (var i = 0; i < element.attributes.length; i++) {\n      attr = element.attributes[i];\n      output[attr.name] = attr.value;\n    }\n  }\n  return output;\n};\n\n/**\n * Reply if an element is in the page viewport\n *\n * @param  {object} el Element to observe\n * @param  {number} h  Percentage of height\n * @return {boolean}\n */\nVivus.prototype.isInViewport = function(el, h) {\n  var scrolled = this.scrollY(),\n    viewed = scrolled + this.getViewportH(),\n    elBCR = el.getBoundingClientRect(),\n    elHeight = elBCR.height,\n    elTop = scrolled + elBCR.top,\n    elBottom = elTop + elHeight;\n\n  // if 0, the element is considered in the viewport as soon as it enters.\n  // if 1, the element is considered in the viewport only when it's fully inside\n  // value in percentage (1 >= h >= 0)\n  h = h || 0;\n\n  return elTop + elHeight * h <= viewed && elBottom >= scrolled;\n};\n\n/**\n * Get the viewport height in pixels\n *\n * @return {integer} Viewport height\n */\nVivus.prototype.getViewportH = function() {\n  var client = this.docElem.clientHeight,\n    inner = window.innerHeight;\n\n  if (client < inner) {\n    return inner;\n  } else {\n    return client;\n  }\n};\n\n/**\n * Get the page Y offset\n *\n * @return {integer} Page Y offset\n */\nVivus.prototype.scrollY = function() {\n  return window.pageYOffset || this.docElem.scrollTop;\n};\n\nsetupEnv = function() {\n  if (Vivus.prototype.docElem) {\n    return;\n  }\n\n  /**\n   * Alias for document element\n   *\n   * @type {DOMelement}\n   */\n  Vivus.prototype.docElem = window.document.documentElement;\n\n  /**\n   * Alias for `requestAnimationFrame` or\n   * `setTimeout` function for deprecated browsers.\n   *\n   */\n  requestAnimFrame = (function() {\n    return (\n      window.requestAnimationFrame ||\n      window.webkitRequestAnimationFrame ||\n      window.mozRequestAnimationFrame ||\n      window.oRequestAnimationFrame ||\n      window.msRequestAnimationFrame ||\n      function(/* function */ callback) {\n        return window.setTimeout(callback, 1000 / 60);\n      }\n    );\n  })();\n\n  /**\n   * Alias for `cancelAnimationFrame` or\n   * `cancelTimeout` function for deprecated browsers.\n   *\n   */\n  cancelAnimFrame = (function() {\n    return (\n      window.cancelAnimationFrame ||\n      window.webkitCancelAnimationFrame ||\n      window.mozCancelAnimationFrame ||\n      window.oCancelAnimationFrame ||\n      window.msCancelAnimationFrame ||\n      function(id) {\n        return window.clearTimeout(id);\n      }\n    );\n  })();\n};\n\n/**\n * Parse string to integer.\n * If the number is not positive or null\n * the method will return the default value\n * or 0 if undefined\n *\n * @param {string} value String to parse\n * @param {*} defaultValue Value to return if the result parsed is invalid\n * @return {number}\n *\n */\nparsePositiveInt = function(value, defaultValue) {\n  var output = parseInt(value, 10);\n  return output >= 0 ? output : defaultValue;\n};\n\n\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], function() {\n      return Vivus;\n    });\n  } else if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = Vivus;\n  } else {\n    // Browser globals\n    window.Vivus = Vivus;\n  }\n\n}());\n\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}